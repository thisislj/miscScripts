#!/usr/bin/env python


'''This script will be used in a cron job to restart jenkins server
peroidically.

This script has to be run by root user so as to run service commands.

It
  # schedules restart jenkins through restful api
  # waits till executing jobs are done
  # restarts jenkins service via service command.

'''


import argparse
import collections
import smtplib
import socket
import subprocess
import sys
import time


from email.mime.text import MIMEText
from pprint import pformat
from urllib2 import Request
from urlparse import urlparse


from Jenkins import Jenkins
from get_ci_jobs import JENKINS_CI, JENKINS_SCMREP
from get_queue_status import (get_jenkins_queue_status,
                              get_jenkins_running_job_status)


messages = []

def log_msg(msg):
    print msg

    messages.append(msg)


def email_msgs(jenkins_url):
    '''send an email notification to build_engineers

    Before sending the email, we try to throttle the messages a little
    bit.
    '''
    # throttle message
    msgs_repeats = collections.OrderedDict()
    for m in messages:
        num_rep = msgs_repeats.get(m, 0)
        num_rep += 1
        msgs_repeats[m] = num_rep

    throttled_msgs = []
    for m, rep in msgs_repeats.items():
        if rep > 1:
            m += '\t\t <-- repeated %s times' % rep
        throttled_msgs.append(m)

    # send it out
    msg = MIMEText('\n'.join(throttled_msgs))

    me = 'build_engineer@bigworldtech.com'
    to = 'build_engineer@bigworldtech.com'
    msg['Subject'] = 'restart %s' % jenkins_url
    msg['from'] = me
    msg['to'] = to

    mail_server = 'mail.bigworldtech.com'
    s = smtplib.SMTP(mail_server)
    s.sendmail(me, [to], msg.as_string())
    s.quit()


def restart_jenkins_service(jenkins_url):
    '''Call service jenkins restart, locally or remotely through ssh.
    '''
    host_name = socket.gethostname()
    jenkins_srv_info = urlparse(jenkins_url)
    jenkins_host_name = jenkins_srv_info.hostname

    remote_exec = host_name != jenkins_host_name

    cmd = ['service', 'jenkins', 'restart',]
    if remote_exec:
        msg = 'host_name: %s, jenkins host name: %s' % (host_name,
                                                        jenkins_host_name)
        log_msg(msg)
        log_msg('restarting jenkins service in %s' % jenkins_host_name)
        # "-o PasswordAuthentication=no" fails the command if password
        # -is required.
        ssh_cmd = ['ssh', '-o', 'PasswordAuthentication=no',
                   'root@%s' % jenkins_host_name,]
        cmd = ssh_cmd + cmd
    else:
        log_msg('restarting jenkins service in %s' % host_name)

    p = subprocess.Popen(cmd,
                         stdout=subprocess.PIPE,
                         stderr=subprocess.PIPE)
    returncode = p.wait()

    if returncode:
        err = p.stderr.read()
        log_msg(err)

    return returncode

def stop_running_jobs(jenkins_srv):
    running_jobs = get_jenkins_running_job_status(jenkins_srv)

    for rj in running_jobs:
        stop_cmd = 'job/%s/%s/stop' % (rj['tags']['job_name'],
                                       rj['tags']['build_num'])
        log_msg('stopped %s' % stop_cmd)
        send_jenkins_command(jenkins_srv, jenkins_srv.server,
                             stop_cmd, post=True)


def get_num_running_jobs(jenkins_srv):
    #num_queued = len(get_jenkins_queue_status(jenkins_srv))
    executing_jobs = get_jenkins_running_job_status(jenkins_srv)
    num_executing = len(executing_jobs)

    log_msg('# of running jobs: %s' % num_executing)
    if num_executing:
        log_msg(pformat([ej['tags'] for ej in executing_jobs]))

    return num_executing


def send_jenkins_command(jenkins_srv, jenkins_url, command, post=False):
    url = '%s/%s' % (jenkins_url, command)
    request = Request(url)

    log_msg('%s %s' % (command, jenkins_url))
    if post:
        # this changes the request to be POST.
        request.add_data('')
    jenkins_srv.jenkins_open(request)

def wait_for_running_jobs_to_finish(jenkins_srv, timeout_seconds,
                                    stop_builds_when_timeout):
    seconds_waited = 0
    seconds_per_round = 6*6
    if seconds_per_round > timeout_seconds:
        seconds_per_round = timeout_seconds

    num_running = get_num_running_jobs(jenkins_srv)
    while num_running:
        msg = '%s running builds, %s seconds to wait' % (num_running,
                                                         timeout_seconds-seconds_waited)
        log_msg(msg)

        timeout = seconds_waited > timeout_seconds
        if timeout:
            if stop_builds_when_timeout:
                # kill running jobs and return
                stop_running_jobs(jenkins_srv)
                stop_builds_when_timeout = False
            else:
                msg = 'After %s seconds, still have %d running builds, ' \
                      'restart canceled' % (timeout_seconds, num_running)
                log_msg(msg)
                raise Exception(msg)

        time.sleep(seconds_per_round)

        seconds_waited += seconds_per_round
        num_running = get_num_running_jobs(jenkins_srv)


def restart_jenkins(jenkins_url, user, passwd, timeout_seconds=7200,
                    stop_builds_when_timeout=False):
    '''schedule restart jenkins through restful api

    wait till executing jobs are done.
    restart it via service command.
    '''
    jenkins_srv = Jenkins(jenkins_url, username=user, password=passwd)

    send_jenkins_command(jenkins_srv, jenkins_url, 'quietDown',
                         post=True)

    retcode = 1
    try:
        wait_for_running_jobs_to_finish(jenkins_srv, timeout_seconds,
                                        stop_builds_when_timeout)
        retcode = restart_jenkins_service(jenkins_url)
    except KeyboardInterrupt:
        log_msg('caught exception: KeyboardInterrupt')
    except Exception, e:
        log_msg('caught exception: %s' % str(e))

    if retcode:
        send_jenkins_command(jenkins_srv, jenkins_url,
                             'cancelQuietDown', post=True)
    return retcode


def get_args():
    '''Get cli arguments. '''
    script_description = '''restart jenkins'''
    argparser = argparse.ArgumentParser(description=script_description)

    argparser.add_argument('--jenkins-url', default='http://localhost:8080',
                           help='jenkins url, e.g. %s %s.' % (JENKINS_CI,
                                                              JENKINS_SCMREP))
    argparser.add_argument('--user', help='jenkins user name')
    argparser.add_argument('--passwd', help='user password')
    argparser.add_argument('--timeout', type=int, default=7200,
                           help='# seconds we wait for existing builds to ' \
                           'finish, by default 7200.')
    argparser.add_argument('--stop-builds-when-timeout', action='store_true',
                           help='if set, stop running builds so as to force ' \
                           'reboot if timed out.')

    args = argparser.parse_args()
    if not args.jenkins_url.startswith('http://'):
        raise Exception('jenkins server url should starts with "http://".')

    return args


if __name__ == '__main__':
    args = get_args()

    jenkins_url, user, passwd, timeout = (args.jenkins_url, args.user,
                                          args.passwd, args.timeout)
    stop_builds_when_timeout = args.stop_builds_when_timeout
    retcode = restart_jenkins(jenkins_url, user, passwd, timeout,
                              stop_builds_when_timeout)
    email_msgs(jenkins_url)

    sys.exit(retcode)
